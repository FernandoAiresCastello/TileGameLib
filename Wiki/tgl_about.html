<!DOCTYPE html>
<html>
<head>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
	<link type="text/css" rel="stylesheet" href="tgl_index.css" media="screen,projection" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta charset="UTF-8">
	<title>TileGameLib (TGL) Docs</title>
</head>
<body>

<!-- HEADER -->

<a name="top"></a>
<table class="page-header">
	<tr>
		<td class="page-header icon">
			<a href="tgl_index.html" class="home-link">
				<img class="gameboy-icon" src="wiki-banner-1.fw.png">
			</a>
		</td>
		<td class="page-header left">
		</td>
	</tr>
</table>

<!-- CONTENT -->

<p class="section-header">TECHNICAL OVERVIEW</p>

<p>
	This is a technical overview of what the library is and how it works.
</p>

<b>What is it exactly?</b>
<p class="horizontal-padding">
	It's basically a barebones game engine for Windows built as a static library that exposes a very simplified API to quickly and easily create 
	tile-based pseudo-8-bit games or prototypes that have a strong GameBoy Color aesthetic.
</p>

<b>Simplified API</b>
<p class="horizontal-padding">
	I have purposely designed the public API to be minimal, so that it can be quick and easy to use. It consists of a single C++ class and a couple 
	of typedefs. All new functions in the public API should be implemented as members of that class, so that the user only has a single entry point 
	to all features of the library. Last time I checked, it had only about 80 functions. Note that certain functions are just meant to avoid passing 
	a single parameter, for example the "kb_" functions to check for keyboard input are implemented individually for every supported scancode that 
	would otherwise be an enum-type argument to a single function. Note that this applies to the public API only. The internal, private API is much 
	more complex (and sometimes messy, and bloated). Explicit use of pointers by the user is avoided, and internal resources are usually referred to 
	by strings, meaning most resources are assigned a string id which can be used to refer to them later.
</p>

<b>Graphics</b>
<p class="horizontal-padding">
	<b>Window:</b> TGL uses the standard windowing system for output, with the resolution fixed at 160x144, which is the same resolution as the original 
	GameBoy Color. The window itself cannot be resized manually, only programmatically via a "scale factor", which basically just scales the entire 
	image to fill a window with different sizes (i.e. it stretches or shrinks all pixels). The window does not update automatically. Everything is drawn 
	on an off-screen pixel buffer. The window can be updated by calling the almighty "system" function, which should be called at the end of each and 
	every frame to allow for the default window event processing, and that includes refreshing the window contents.

<p class="horizontal-padding">	
	<b>Tiles:</b> All tiles are strictly 8x8 pixels, and larger graphics can only be drawn by "stitching them together" like a mosaic, just like the GBC. 
	Currently it does not support loading images from external files. Tiles are limited to 4 colors, or 3 colors if one of them is	
	invisible (yes, just like transparent sprites on the GBC). They are created directly in code using "pixel patterns": those are merely 
	strings of length 64 (i.e. 8x8) containing the characters '0', '1', '2' or '3' indicating the color index of a pixel. The "pixel patterns" are 
	stored internally in a so-called "tile pattern set", and the tiles themselves are sequences of tile patterns, which allows for every tile to 
	be animated automatically (or not, if it has a single frame). All tiles are stored in the internal tileset.
</p>
<p class="horizontal-padding">
	<b>Pixels:</b> Individual pixels can only be manipulated on a tile-by-tile basis, meaning 8x8 "pixel patterns" must be manipulated in the internal 
	tileset before drawing anything on the screen, again similar to the GBC concept of "tile memory". As such, direct access to the internal pixel buffer 
	is not provided.
</p>
<p class="horizontal-padding">
	<b>Sprites:</b> Those can be simulated by using tiles that have "transparent" backgrounds. This is achieved by specifying 3 colors instead of 4 when 
	drawing any regular tile, in which case only the indices 1, 2 and 3 are specified, the index 0 is the transparency key. Transparency here has nothing 
	to do with alpha transparency or blending (TGL does not support color blending). It simply means that pixels assigned with the index 0 will not be 
	drawn.
</p>
<p class="horizontal-padding">
	<b>Colors:</b> There is no "color palette" as in the GBC. Colors are encoded in the typical RGB format. Individual tiles contain 4 color indexes, 
	or 3 if it's a "sprite" tile (since the index 0 is considered transparent for sprites) which are assigned to each individual tile as they are drawn. 
	Remember that each tile contains pixel patterns consisting of indexes 0, 1, 2 or 3, and the API provides functions to specify what are the current 
	4 (or 3) colors to be used for each index in the next tiles that will be drawn.
</p>
<p class="horizontal-padding">
	<b>Layering:</b> The API has no concept of "layers", but this can be easily achieved by the order in which individual tiles and views are drawn.
</p>
<p class="horizontal-padding">
	<b>Views:</b> There is a "viewport" system that can be used to simulate the so-called "windows" in the GBC, meaning all drawing is limited to the 
	area of the currently active view. There can be multiple overlapping views and each view can be "scrolled" independently, meaning pixels will only 
	be visible if they are drawn within the current viewport area starting from the current x and y scroll offset. This is used to simulate the scrolling 
	backgrounds on the GBC.
</p>
<p class="horizontal-padding">
	<b>Rendering Mode:</b> The graphics system mostly follows the immediate mode pattern, wherein every single tile must be drawn directly by function calls, as opposed to 
	retained mode where the API would manage all drawing internally. This is opposed to the original GBC which has a "tile buffer" in memory.
</p>
<p class="horizontal-padding">
	Help is needed most with performance issues, especially during rendering, since TGL draws the entire screen pixel by pixel and it's currently 
	not optimized for speed. Also, the framerate is currently very unstable, so help with making everything run smoothly would be greatly appreciated.
</p>

<b>Text</b>
<p class="horizontal-padding">
	Text drawing is simply implemented as a string of tiles. The default font can be redefined by the user, and each character is stored as a pixel 
	pattern, just like the tileset. You can think of the font as just a special separate internal tileset.
</p>

<b>Sound</b>
<p class="horizontal-padding">
	The sound system currently works with very rudimentary (and probably buggy) square-wave sound synthesis only, since I have limited knowledge of 
	audio programming. This is another area where any help is appreciated.
</p>

<b>User Input</b>
<p class="horizontal-padding">
	Currently, keyboard and mouse input are implemented. Gamepad/controller input is in the TODO list and I intend to work on this very soon.
</p>

<b>Collision Detection</b>
<p class="horizontal-padding">
	I have implemented very basic collision detection that works on an tile-by-tile basis, meaning it simply calculates if two 8x8 tiles overlap based 
	on their x and y coordinates. This is provided mostly for convenience only, so currently there are no plans to expand the collision detection system.
</p>

<b>Timers</b>
<p class="horizontal-padding">
	This is a very simple feature to help coordinate the timing of stuff. There is basically an internal set of countdown timers where each timer is a 
	counter that starts from some specified integer number down to 0. Once the timer reaches 0, it can be automatically reset, causing the timer to 
	repeat. This can be used to simulate interval-based events. All enabled timers can be advanced at the same time upon calling the almighty "system" 
	function, which should be called at the end of each and every frame as discussed in the next section.
</p>

<b>System</b>
<p class="horizontal-padding">
	There is a so-called "almighty" system function, which is appropriately called "system()". It is intended to be called at the end of each and every 
	frame. The purpose of this function is to update internal states such as advancing timers and handling the default window processing events, for
	instance it allows moving and closing the window, and pressing ALT+ENTER at any moment to toggle fullscreen mode. It is also responsible for 
	updating the window with everything that has been drawn since the last call to "system()" (i.e. the current off-screen framebuffer gets copied to 
	the window surface) and also coordinates the built-in animation thread.
</p>

<a href="tgl_index.html" class="back-home">Back to Home</a>

</body>
</html>
